function [td,s,frequencyBuffer,isH,frequencyID] = stimGen_dynamic_HL_toneClouds(loFreq,hiFreq,toneDur,toneSOA,trialDur,freqType,freqWidth,nFreq,cohLevel,changeTime,changeRamp,fs)
% stimGen_static_HL_v2 generates a sequence of tone bursts of from 2 frequency distribitions (loFreq & hiFreq)
% Each tone lasts 'toneDur' ms and is followed by an inter-tone interval of 'toneSOA'.
% Length of the audio stream is 'trialDur' ms.
% Patterns of loFreq and hiFreq tones is determined by 'freqList'
% determined by list of letters e.g. LLL, HLL, HHL, LNL, HSH and all other combinations
% H for High | L for Low | N for Noise | S for Silence.
% Width of frequency distributions is determined by 'freqWidth' (unit = n octaves)
% and the number of frequencies generated by the distribution is 'nFreq'.
% Coherence level can vary between 0-1: 
% 0 means 100% tones from low-frequency distribution
% 1 means 100% tones from high-frequency distribution.
% If length(cohLevel) == length(freqList), coherence level is set for each frequency fraction.
% Time points on which one frequency changes to the next is set using 'changeTime'. 
% length(changeTime) has to match length(freqList)-1
% Frequency change can be abrupt or ramping 
% 'changRamp' has to be larger than toneDur+toneSOA to set ramping slope,
% otherwise the change will be abrupt.


% INPUT:
% loFreq    - lowest frequency in Hz (> 300 Hz)
% hiFreq    - highest frequency in Hz (< 10000 Hz and 2 octaves above loFreq)
% toneDur   - tone duration in ms
% toneSOA   - stimulus onset asynchrony = inter-tone interval in ms
% trialDur  - trial duration in ms
% freqType  - frequency patterns [L | LNL | LSL | HNH | HSH | H]
% freqWidth - width of frequency distribution, used to generate the 'tone clouds'
% cohLevel  - coherence level for high-frequency tone [0.5 - 1] (1-cohLevel for low-frequency tone)
% changeTime - time points when one frequency changes from one to the next
% changeRamp - time span (ms) of change slope (< toneDur+toneSOA - abrupt change)

% OUTPUT:
% td - time bins
% s - auditory stream

%% some default variable for function testing
% loFreq = 625; %hz      312.5 |  625 | 1250 | 2500 |  5000
% hiFreq = 2500; %hz     625   | 1250 | 2500 | 5000 | 10000
% freqWidth = 1; %octave
% nFreq = 7; %levels
% toneDur = 40; %ms
% toneSOA = 10; %ms
% trialDur = 2000; %ms
% freqType = 'HNH';
% cohLevel = 1;
% changeTime = [300 1000]; %ms
% changeRamp = 500; %ms

%% check inputs
if any(changeTime>trialDur), disp('invalid changeTime input: later than trial length'); return; end
if length(changeTime) ~= length(freqType)-1, disp('invalid changeTime or freqType input: lengths do not match'); return; end
if any(diff(changeTime)<changeRamp), disp('invalid changeTime interval: at least one interval is smaller than ramping time'); return; end

%% generate sequence of coherence values
% assign high & low & noise coherence levels
if length(cohLevel) == 1
    hiCoh = cohLevel;
    loCoh = 1-cohLevel;
end
noCoh = 0.5;
% add first time bin to changeTime

if changeTime(1) == 0
    changeTime = changeTime(2:end);
    freqType = freqType(2:end);
end
    
changeTime = [1, changeTime];

minLoFreq = loFreq * 10.^(log10(2) * -(freqWidth));
maxLoFreq = loFreq * 10.^(log10(2) * freqWidth);
minHiFreq = hiFreq * 10.^(log10(2) * -(freqWidth));
maxHiFreq = hiFreq * 10.^(log10(2) * freqWidth);
loRange = minLoFreq * 10.^(log10(2) * (0:(2*freqWidth)/(nFreq-1):ceil(log10(maxLoFreq/minLoFreq)/log10(2))));
hiRange = minHiFreq * 10.^(log10(2) * (0:(2*freqWidth)/(nFreq-1):ceil(log10(maxHiFreq/minHiFreq)/log10(2))));

noFreq = loFreq * 10.^(log10(2) * ceil(log10(hiFreq/loFreq)/log10(2))/2);
%% gradual change
toneDurTot = toneSOA+toneDur;
numTonePresentations = floor(trialDur/toneDurTot);

% convert times (ms) to coherence bins - depending on tone length
changeBins = unique(ceil((changeTime+toneSOA+toneDur/2)/toneDurTot));

coh = zeros(1,numTonePresentations);
ind_begin = 1;
for ff = 1:length(freqType)  
    if length(cohLevel) > 1
        hiCoh = cohLevel(ff);
        loCoh = 1 - cohLevel(ff);
    end
    switch freqType(ff)
        case 'H', tmpCoh = hiCoh;       % high frequency
        case 'L', tmpCoh = loCoh;       % low frequency
        case 'N', tmpCoh = noCoh;       % noisy signal
        case 'S', tmpCoh = nan;         % absence of signal (silence)
    end

    if ff < length(freqType)
        ind_end = changeBins(ff+1);
        coh(ind_begin:ind_end-1) = tmpCoh * ones(1,ind_end-ind_begin);
        ind_begin = ind_end;
    else
        ind_end = numTonePresentations;
        coh(ind_begin:ind_end) = tmpCoh * ones(1,ind_end-ind_begin+1);
    end
    
    
    % in case of ramping change
    if changeRamp > toneDurTot && ff < length(freqType)
        nSteps = floor(changeRamp/toneDurTot)+1;
        if length(cohLevel) > 1
            next_hiCoh = cohLevel(ff+1);
            next_loCoh = 1 - cohLevel(ff+1);
        else
            next_hiCoh = hiCoh;
            next_loCoh = loCoh;
        end
        switch freqType(ff+1)
            case 'H', rampCoh = tmpCoh:(next_hiCoh-tmpCoh)/nSteps:next_hiCoh;
            case 'L', rampCoh = tmpCoh:(next_loCoh-tmpCoh)/nSteps:next_loCoh;
            case 'N', rampCoh = tmpCoh:(noCoh-tmpCoh)/nSteps:noCoh;
            case 'S', rampCoh = repmat(tmpCoh,1,nSteps+1); % no ramping in case of silent pause
        end
        % take only the transitional steps - remove first (current) & last (next) coherence levels
        rampCoh = rampCoh(2:end-1);
        ind_end = ind_begin + length(rampCoh) - 1;
        coh(ind_begin:ind_end) = rampCoh;
        ind_begin = ind_end + 1;
    end
end

% calc no. of tone presentations
bufferLen = ceil(trialDur/toneDurTot);
frequencyBuffer = nan(1,bufferLen);
frequencyID = nan(1,bufferLen);

%% change high freq to low freq depending on coherence level by permuting tones in a block of the same coherence

cohChanges = [1 find(diff(coh))+1 numTonePresentations+1];
ind = 0;
for cc = 2:length(cohChanges)
    ind_coh = cohChanges(cc-1);
    numToneinBloc = cohChanges(cc) - ind_coh;
    if ~isnan(coh(ind_coh))
        numToShuffle = round((1-coh(ind_coh))*numToneinBloc);
        permIdx = randperm(numToneinBloc);
        lowIdx = permIdx(1,1:numToShuffle);
        hiIdx = permIdx(1,numToShuffle+1:end);
        
        if ~isempty(lowIdx)
            frequencyBuffer(ind+lowIdx) = loRange(randi(nFreq,1,numToShuffle)); % pick frequencies from low freq range
            frequencyID(ind+lowIdx) = loFreq;
        end
        if ~isempty(hiIdx)
            frequencyBuffer(ind+hiIdx) = hiRange(randi(nFreq,1,numToneinBloc-numToShuffle)); % pick frequencies from high freq range
            frequencyID(ind+hiIdx) = hiFreq;
        end
    else
        frequencyBuffer(ind+1:ind+numToneinBloc) = nan;
    end
    ind = ind + numToneinBloc;
end

numLo = sum(frequencyBuffer < noFreq);
numHi = sum(frequencyBuffer > noFreq);

isH = numHi > numLo;

%% generate random numbers and compare against coherence values

% tmp_rand = rand(1,numTonePresentations);
% ind_change = tmp_rand >= coh;
% numLo = length(find(ind_change));
% frequencyBuffer(ind_change) = loRange(randi(nFreq,1,numLo)); % pick frequencies from low freq range
% numHi = length(find(~ind_change));
% frequencyBuffer(~ind_change) = hiRange(randi(nFreq,1,numHi)); % pick frequencies from high freq range

% ind_nan = isnan(coh);
% frequencyBuffer(ind_nan) = nan;

%% generate sequence of tones
% fs = 384000;%384000;%12000;
rampLength = 5;
cosRamp = (rampLength/1000)*fs;

multiplier = fs/1000;
s = zeros(1,trialDur*multiplier);
f = nan(1,trialDur*multiplier);
for ii = 1:numTonePresentations
    ind = (ii-1)*(toneSOA+toneDur)*multiplier + 1;
    if ~isnan(frequencyBuffer(ii))
        tmax = toneDur/1000;                               % Time Duration Of Signal (sec)
        t = linspace(0, tmax, tmax*fs);                          % Time Vector
        freq = frequencyBuffer(ii);                                 % Original Frequency
        tone = sin(2*pi*freq*t);% Original Signal %TODO: multiply voltage - from calib
        tone = pa_ramp(tone, cosRamp, fs);
        s(ind:ind+toneDur*multiplier-1) = tone';
        f(ind:ind+toneDur*multiplier-1) = freq;
    end
end

td = 0:1/fs:(length(s)-1)/fs;

%% for testing - listen
% sound(s, fs) 
% 
% % record
% filename = 'sample_stim_toneClouds_2dist.wav';
% audiowrite(filename,s,fs)
%% for testing - plot

% temp_fig_path = '/dataAnalysis/git_public/Penn_auditoryDecision/stimuli/';
% fig_name = 'sample_stim2_toneplot';
% h = figure('Name',fig_name,'Position',get(0,'ScreenSize'));
% subplot(2,1,1)
% tone = sin(2*pi*freq*t);
% plot(tone)
% tone = pa_ramp(tone, cosRamp, fs);
% subplot(2,1,2)
% plot(tone)
% saveas(h,[temp_fig_path fig_name '.fig']);
% save2pdf([temp_fig_path fig_name '.pdf'],h);
% clf
% 
% % 
% % plot(td,s)
% % xlabel('Time (ms)')
% % ylabel('Amplitude')
% % title('Signal')
% 

% maxFreq = ceil(max(frequencyBuffer));
% temp_fig_path = '/dataAnalysis/git_public/Penn_auditoryDecision/stimuli/';
% fig_name = 'sample_stim_toneClouds_2dist_plot';
% h = figure('Name',fig_name,'Position',get(0,'ScreenSize'));
% subplot(2,1,1)
% plot(td,f/1000)
% line([td(1) td(end)], [loFreq/1000 loFreq/1000],'LineStyle','--','Color',[0.5 0.5 0.5])
% line([td(1) td(end)], [hiFreq/1000 hiFreq/1000],'LineStyle','--','Color',[0.5 0.5 0.5])
% text(td(end),(hiFreq+100)/1000,['numHi = ' num2str(numHi)],'HorizontalAlignment','right');
% text(td(end),(loFreq-100)/1000,['numLo = ' num2str(numLo)],'HorizontalAlignment','right');
% xlabel('Time (secs)')
% ylabel('Frequency(Hz)')
% ylim([0 ceil(maxFreq/1000)])
% % 
% subplot(2,1,2)
% segmentLength = round(numel(s)/5);
% % window = hamming(512);
% % noverlap = 256;
% % nfft = 512;
% % [S,F,T,P] = spectrogram(s,window,noverlap,nfft,fs,'yaxis');
% % surf(T,F,10*log10(P),'edgecolor','none'); axis tight; view(0,90);
% % colormap(hot)
% % set(gca,'clim',[-80 -30])
% % ylim([0 3])
% % 
% % periodogram(s,[],[],fs)
% 
% % spectrogram(s,segmentLength,[],[],fs,'yaxis')
% spectrogram(s,round(segmentLength/5),round(80/100*segmentLength/5),[],fs,'yaxis')
% % spectrogram(s,round(numel(s)/25),[],round(numel(s)/25),fs,'yaxis')
% ylim([0 ceil(maxFreq/1000)])
% saveas(h,[temp_fig_path fig_name '.fig']);
% save2pdf([temp_fig_path fig_name '.pdf'],h);
% close(gcf)